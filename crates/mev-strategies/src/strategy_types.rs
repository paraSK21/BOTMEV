//! Core strategy types and interfaces for MEV bot

use anyhow::Result;
use mev_core::{ParsedTransaction, SimulationBundle, SimulationResult};
use serde::{Deserialize, Serialize};
use std::{collections::HashMap, sync::Arc};
use tokio::sync::RwLock;

/// MEV opportunity detected by a strategy
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Opportunity {
    pub id: String,
    pub strategy_name: String,
    pub target_transaction: ParsedTransaction,
    pub opportunity_type: OpportunityType,
    pub estimated_profit_wei: u128,
    pub estimated_gas_cost_wei: u128,
    pub confidence_score: f64, // 0.0 to 1.0
    pub priority: u8,          // 0-255, higher = more urgent
    pub expiry_timestamp: u64,
    pub metadata: HashMap<String, String>,
}

/// Types of MEV opportunities
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum OpportunityType {
    Arbitrage {
        token_in: String,
        token_out: String,
        amount_in: u128,
        expected_profit: u128,
        dex_path: Vec<String>,
    },
    Backrun {
        target_tx_hash: String,
        affected_token: String,
        price_impact: f64,
        follow_up_action: String,
    },
    Sandwich {
        victim_tx_hash: String,
        token_pair: (String, String),
        front_run_amount: u128,
        back_run_amount: u128,
        expected_profit: u128,
    },
    Liquidation {
        protocol: String,
        position_owner: String,
        collateral_token: String,
        debt_token: String,
        liquidation_amount: u128,
        liquidation_bonus: f64,
    },
}

/// Bundle plan generated by a strategy
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BundlePlan {
    pub id: String,
    pub strategy_name: String,
    pub opportunity_id: String,
    pub transactions: Vec<PlannedTransaction>,
    pub estimated_gas_total: u128,
    pub estimated_profit_wei: u128,
    pub risk_score: f64, // 0.0 to 1.0, higher = riskier
    pub execution_deadline: u64,
}

/// Individual transaction in a bundle plan
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PlannedTransaction {
    pub transaction_type: TransactionType,
    pub to: String,
    pub value: u128,
    pub gas_limit: u128,
    pub gas_price: u128,
    pub data: String,
    pub description: String,
}

/// Types of transactions in a bundle
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum TransactionType {
    FrontRun,
    Target,
    BackRun,
    Arbitrage,
    Liquidation,
}

/// Strategy evaluation result
#[derive(Debug, Clone)]
pub enum StrategyResult {
    Opportunity(Opportunity),
    BundlePlan(BundlePlan),
    NoOpportunity,
    Error(String),
}

/// Strategy configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StrategyConfig {
    pub name: String,
    pub enabled: bool,
    pub priority: u8,
    pub min_profit_wei: u128,
    pub max_gas_price_gwei: u64,
    pub risk_tolerance: f64, // 0.0 to 1.0
    pub parameters: HashMap<String, serde_json::Value>,
}

impl Default for StrategyConfig {
    fn default() -> Self {
        Self {
            name: "default".to_string(),
            enabled: true,
            priority: 128,
            min_profit_wei: 1_000_000_000_000_000, // 0.001 ETH
            max_gas_price_gwei: 100,
            risk_tolerance: 0.5,
            parameters: HashMap::new(),
        }
    }
}

/// Core strategy trait that all MEV strategies must implement
#[async_trait::async_trait]
pub trait Strategy: Send + Sync {
    /// Get strategy name
    fn name(&self) -> &str;

    /// Get strategy configuration
    fn config(&self) -> &StrategyConfig;

    /// Update strategy configuration
    fn update_config(&mut self, config: StrategyConfig) -> Result<()>;

    /// Evaluate a transaction for MEV opportunities
    async fn evaluate_transaction(&self, tx: &ParsedTransaction) -> Result<StrategyResult>;

    /// Create a bundle plan from an opportunity
    async fn create_bundle_plan(&self, opportunity: &Opportunity) -> Result<BundlePlan>;

    /// Validate a bundle plan before execution
    async fn validate_bundle(&self, bundle: &SimulationBundle) -> Result<bool>;

    /// Post-execution analysis and learning
    async fn analyze_execution(&self, bundle_plan: &BundlePlan, result: &SimulationResult) -> Result<()>;

    /// Get strategy statistics
    fn get_stats(&self) -> StrategyStats;

    /// Reset strategy statistics
    fn reset_stats(&mut self);
}

/// Strategy performance statistics
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct StrategyStats {
    pub opportunities_detected: u64,
    pub bundles_created: u64,
    pub bundles_executed: u64,
    pub successful_executions: u64,
    pub total_profit_wei: u128,
    pub total_gas_spent_wei: u128,
    pub average_profit_per_execution: f64,
    pub success_rate: f64,
    pub average_confidence_score: f64,
}

impl StrategyStats {
    pub fn record_opportunity(&mut self, confidence: f64) {
        self.opportunities_detected += 1;
        self.update_average_confidence(confidence);
    }

    pub fn record_bundle_creation(&mut self) {
        self.bundles_created += 1;
    }

    pub fn record_execution(&mut self, success: bool, profit_wei: u128, gas_cost_wei: u128) {
        self.bundles_executed += 1;
        if success {
            self.successful_executions += 1;
            self.total_profit_wei += profit_wei;
        }
        self.total_gas_spent_wei += gas_cost_wei;
        self.update_success_rate();
        self.update_average_profit();
    }

    fn update_success_rate(&mut self) {
        if self.bundles_executed > 0 {
            self.success_rate = self.successful_executions as f64 / self.bundles_executed as f64;
        }
    }

    fn update_average_profit(&mut self) {
        if self.successful_executions > 0 {
            self.average_profit_per_execution = self.total_profit_wei as f64 / self.successful_executions as f64;
        }
    }

    fn update_average_confidence(&mut self, new_confidence: f64) {
        if self.opportunities_detected == 1 {
            self.average_confidence_score = new_confidence;
        } else {
            let total = self.average_confidence_score * (self.opportunities_detected - 1) as f64;
            self.average_confidence_score = (total + new_confidence) / self.opportunities_detected as f64;
        }
    }

    pub fn print_summary(&self) {
        tracing::info!(
            strategy_stats = ?self,
            "Strategy performance statistics"
        );
    }
}

/// Strategy registry for managing multiple strategies
pub struct StrategyRegistry {
    strategies: Arc<RwLock<HashMap<String, Box<dyn Strategy>>>>,
}

impl StrategyRegistry {
    pub fn new() -> Self {
        Self {
            strategies: Arc::new(RwLock::new(HashMap::new())),
        }
    }

    /// Register a new strategy
    pub async fn register_strategy(&self, strategy: Box<dyn Strategy>) -> Result<()> {
        let name = strategy.name().to_string();
        let mut strategies = self.strategies.write().await;
        strategies.insert(name.clone(), strategy);
        tracing::info!(strategy_name = %name, "Strategy registered");
        Ok(())
    }

    /// Get a strategy by name
    pub async fn get_strategy(&self, _name: &str) -> Option<Box<dyn Strategy>> {
        let _strategies = self.strategies.read().await;
        // Note: This is a simplified version. In practice, you'd need to handle cloning differently
        // since Box<dyn Strategy> doesn't implement Clone
        None // Placeholder
    }

    /// List all registered strategies
    pub async fn list_strategies(&self) -> Vec<String> {
        let strategies = self.strategies.read().await;
        strategies.keys().cloned().collect()
    }

    /// Get enabled strategies
    pub async fn get_enabled_strategies(&self) -> Vec<String> {
        let strategies = self.strategies.read().await;
        strategies
            .values()
            .filter(|s| s.config().enabled)
            .map(|s| s.name().to_string())
            .collect()
    }
}

impl Default for StrategyRegistry {
    fn default() -> Self {
        Self::new()
    }
}

/// Utility functions for strategy implementations
pub mod strategy_utils {
    use super::*;

    /// Calculate profit after gas costs
    pub fn calculate_net_profit(gross_profit_wei: u128, gas_cost_wei: u128) -> i128 {
        gross_profit_wei as i128 - gas_cost_wei as i128
    }

    /// Estimate gas cost for a transaction
    pub fn estimate_gas_cost(gas_limit: u128, gas_price_gwei: u64) -> u128 {
        gas_limit * (gas_price_gwei as u128 * 1_000_000_000)
    }

    /// Calculate confidence score based on various factors
    pub fn calculate_confidence_score(
        profit_margin: f64,
        gas_price_stability: f64,
        market_volatility: f64,
    ) -> f64 {
        let base_confidence = profit_margin.min(1.0).max(0.0);
        let gas_factor = gas_price_stability.min(1.0).max(0.0);
        let volatility_factor = (1.0 - market_volatility).min(1.0).max(0.0);
        
        (base_confidence * 0.5 + gas_factor * 0.3 + volatility_factor * 0.2).min(1.0).max(0.0)
    }

    /// Generate unique opportunity ID
    pub fn generate_opportunity_id(strategy_name: &str, tx_hash: &str) -> String {
        format!("{}_{}_{}",
            strategy_name,
            &tx_hash[2..10], // First 8 chars of hash
            chrono::Utc::now().timestamp_millis()
        )
    }

    /// Check if opportunity is still valid
    pub fn is_opportunity_valid(opportunity: &Opportunity) -> bool {
        let current_time = chrono::Utc::now().timestamp() as u64;
        current_time < opportunity.expiry_timestamp
    }

    /// Calculate priority score based on profit and confidence
    pub fn calculate_priority_score(profit_wei: u128, confidence: f64, base_priority: u8) -> u8 {
        let profit_factor = (profit_wei as f64 / 1_000_000_000_000_000_000.0).min(2.0); // Normalize to ETH
        let priority_boost = (profit_factor * confidence * 50.0) as u8;
        (base_priority as u16 + priority_boost as u16).min(255) as u8
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use super::strategy_utils::*;

    #[test]
    fn test_calculate_net_profit() {
        let gross_profit = 1_000_000_000_000_000_000; // 1 ETH
        let gas_cost = 100_000_000_000_000_000;       // 0.1 ETH
        let net_profit = calculate_net_profit(gross_profit, gas_cost);
        assert_eq!(net_profit, 900_000_000_000_000_000); // 0.9 ETH
    }

    #[test]
    fn test_calculate_confidence_score() {
        let confidence = calculate_confidence_score(0.8, 0.9, 0.3);
        assert!(confidence > 0.0 && confidence <= 1.0);
        assert!(confidence > 0.5); // Should be reasonably high with good inputs
    }

    #[test]
    fn test_strategy_stats() {
        let mut stats = StrategyStats::default();
        
        stats.record_opportunity(0.8);
        stats.record_bundle_creation();
        stats.record_execution(true, 1_000_000_000_000_000_000, 100_000_000_000_000_000);
        
        assert_eq!(stats.opportunities_detected, 1);
        assert_eq!(stats.bundles_created, 1);
        assert_eq!(stats.bundles_executed, 1);
        assert_eq!(stats.successful_executions, 1);
        assert_eq!(stats.success_rate, 1.0);
    }

    #[test]
    fn test_generate_opportunity_id() {
        let id = generate_opportunity_id("arbitrage", "0x1234567890abcdef");
        assert!(id.starts_with("arbitrage_12345678_"));
        assert!(id.len() > 20);
    }

    #[test]
    fn test_calculate_priority_score() {
        let priority = calculate_priority_score(
            1_000_000_000_000_000_000, // 1 ETH profit
            0.9,                       // High confidence
            100,                       // Base priority
        );
        assert!(priority > 100);
        assert!(priority <= 255);
    }
}