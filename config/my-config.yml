# ============================================================================
# HyperLiquid Dual-Channel Architecture Configuration
# ============================================================================
# 
# IMPORTANT: HyperLiquid EVM does NOT support traditional mempool monitoring.
# Pending transactions cannot be queried via eth_newPendingTransactionFilter
# or similar RPC methods.
#
# Instead, this bot uses a dual-channel architecture:
#
# 1. WebSocket Channel (ws_url):
#    - Connects to HyperLiquid's native API for real-time market data
#    - Receives trade executions, order book updates, and price feeds
#    - Provides low-latency market signals for opportunity detection
#
# 2. RPC Channel (rpc_url):
#    - Polls blockchain state at regular intervals (polling_interval_ms)
#    - Queries smart contract states, token prices, and balances
#    - Submits transactions when opportunities are identified
#    - Tracks transaction confirmations
#
# This architecture combines the speed of WebSocket market data with the
# reliability of RPC blockchain queries to identify and execute profitable
# trading opportunities without relying on mempool access.
#
# ============================================================================

hyperliquid:
  # Enable/disable HyperLiquid integration
  enabled: true
  
  # WebSocket endpoint for HyperLiquid's native API (market data streaming)
  # This endpoint provides real-time trades, order books, and market events
  ws_url: "wss://api.hyperliquid.xyz/ws"
  
  # RPC endpoint for blockchain operations (state queries and transaction submission)
  # RECOMMENDED: Use QuickNode or another premium RPC provider for better performance
  # The RPC endpoint is used for:
  #   - Polling blockchain state (block numbers, contract states, balances)
  #   - Submitting transactions to the network
  #   - Tracking transaction confirmations
  # 
  # Replace with your QuickNode endpoint URL:
  rpc_url: "https://cosmopolitan-quaint-voice.hype-mainnet.quiknode.pro/a9505f9f6a8b4c02dc0e27392eefc2d44ff1aec1/evm"
  
  # Private key for transaction signing (use environment variable for security)
  private_key: ""  # Will be loaded from environment variable at runtime
  
  # Polling interval for RPC blockchain state queries (in milliseconds)
  # Default: 1000ms (1 second) - adjust based on your latency requirements
  # Lower values = more frequent updates but higher RPC usage
  # Higher values = less RPC usage but potentially stale data
  polling_interval_ms: 1000
  
  # Trading pairs to monitor (coin symbols)
  trading_pairs:
    - "BTC"
    - "ETH"
    - "SOL"
    - "ARB"
  
  # Subscribe to order book updates (optional, provides L2 order book data)
  subscribe_orderbook: false
  
  # Reconnection settings for WebSocket connection failures
  reconnect_min_backoff_secs: 1
  reconnect_max_backoff_secs: 60
  max_consecutive_failures: 10
  
  # Token mapping: Maps HyperLiquid coin symbols to EVM token addresses
  # This enables cross-exchange arbitrage between HyperLiquid and EVM DEXes
  token_mapping:
    BTC: "0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599"  # WBTC on Ethereum
    ETH: "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2"  # WETH on Ethereum
    SOL: "0x5288738df1aB05A68337cB9dD7a607285Ac3Cf90"  # SOL (example address)
    ARB: "0x912CE59144191C1204E64559FE8253a0e49E6548"  # ARB token
    USDC: "0xA0b86a33E6441b8c4C8C0C8C0C8C0C8C0C8C0C8C"  # USDC on Ethereum (for arbitrage)

# Bot Configuration
bot:
  max_gas_price: 50000000000   # 50 gwei (adjust based on network conditions)
  min_profit_threshold: 0.005  # 0.5% minimum profit for arbitrage (lower threshold for more opportunities)
  strategies:
    - "arbitrage"
  
  # Arbitrage-specific settings
  arbitrage:
    max_slippage: 0.001        # 0.1% max slippage
    min_volume_usd: 1000       # Minimum $1000 volume for arbitrage
    max_position_size: 0.1     # Maximum 10% of portfolio per trade
    cross_exchange_enabled: true  # Enable cross-exchange arbitrage

# Performance Settings
performance:
  worker_threads: 4
  ring_buffer_size: 10000
  simulation_timeout_ms: 100
  max_concurrent_simulations: 50
  cpu_core_pinning: false
  core_ids: [0, 1, 2, 3]
  backpressure:
    enabled: true
    drop_policy: "oldest"
    high_watermark: 0.8
    low_watermark: 0.6

# Monitoring
monitoring:
  prometheus_port: 9091  # Changed from 9090 to avoid conflict
  log_level: "info"  # Use "debug" for more detailed logs
